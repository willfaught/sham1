(module Transformation mzscheme
  (require (lib "contract.ss")
           (lib "list.ss")
           (lib "match.ss")
           (prefix c/ (lib "CoreSyntax.ss" "sham" "haskell"))
           (prefix h/ (lib "HaskellSyntax.ss" "sham" "haskell"))
           (prefix t/ (lib "Types.ss" "sham")))
  
  (provide/contract (transformSyntax (-> h/HaskellSyntax? c/CoreSyntax?))
                    (transformType (-> h/HaskellSyntax? t/Type?)))
  
  (define/contract curry (-> (listof string?) c/CoreSyntax? c/CoreSyntax?)
    (lambda (params body)
      (if (null? params) body (c/make-Function (car params) (curry (cdr params) body)))))
  
  (define/contract transformSyntax (-> h/HaskellSyntax? c/CoreSyntax?)
    (match-lambda
      (($ h/Application r d) (c/make-Application (transformSyntax r) (transformSyntax d)))
      (($ h/Character v) (c/make-Character v))
      (($ h/Constructor n f) (c/make-Constructor n (map transformSyntax f)))
      (($ h/Data n c) (c/make-Data n (map transformSyntax c)))
      (($ h/Declaration ($ h/LHS n p) r) (c/make-Declaration n (curry p (transformSyntax r))))
      (($ h/Field n t) (c/make-Field n (transformType t)))
      (($ h/Float v) (c/make-Float v))
      (($ h/Function p b) (curry p (transformSyntax b)))
      (($ h/If g t e) (c/make-If (transformSyntax g) (transformSyntax t) (transformSyntax e)))
      (($ h/Integer v) (c/make-Integer v))
      (($ h/Let d b) (c/make-Let (map transformSyntax d) (transformSyntax b)))
      (($ h/List e) (foldr (lambda (x y) (c/make-Application (c/make-Application (c/make-Variable ":") (transformSyntax x)) y)) (c/make-ListConstructor) e))
      (($ h/ListConstructor) (c/make-ListConstructor))
      (($ h/ML t n) (c/make-ML t n))
      (($ h/Module n ($ h/Body _ d)) (c/make-Module n (map transformSyntax d)))
      (($ h/Scheme t n) (c/make-Scheme t n))
      (($ h/Tuple e) (foldl (lambda (x y) (c/make-Application y (transformSyntax x))) (c/make-TupleConstructor (length e)) e))
      (($ h/TupleConstructor a) (c/make-TupleConstructor a))
      (($ h/UnitConstructor) (c/make-UnitConstructor))
      (($ h/Variable n) (c/make-Variable n))))
  
  (define/contract transformType (-> h/HaskellSyntax? t/Type?)
    (match-lambda
      (($ h/FunctionType p r) (t/make-Application (t/make-Application (t/make-Function) (transformType p)) (transformType r)))
      (($ h/ListType t) (t/make-Application (t/make-List) (transformType t)))
      (($ h/TupleType t) (foldl (lambda (x y) (t/make-Application y (transformType x))) (t/make-Tuple (length t)) t))
      (($ h/TypeApplication t) (foldl (lambda (x y) (t/make-Application y (transformType x))) (transformType (car t)) (cdr t)))
      (($ h/TypeConstructor n) (t/make-Constructor n))
      (($ h/TypeVariable n) (t/make-Variable n))
      (($ h/UnitType) (t/make-Unit)))))