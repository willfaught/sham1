(module Parsing scheme
  (require (lib "lex.ss" "parser-tools")
           (prefix-in : (lib "lex-sre.ss" "parser-tools"))
           (lib "readerr.ss" "syntax")
           (lib "yacc.ss" "parser-tools")
           (lib "HaskellSyntax.ss" "sham" "haskell")
           (lib "List.ss" "sham" "haskell")
           (lib "Maybe.ss" "sham" "haskell")
           (prefix-in t/ (lib "Types.ss" "sham")))
  
  (provide languageLexer (rename-out (getParsers parsers) (getParser parser)))
  
  (define-lex-abbrevs
    (a-whitespace (:: a-whitestuff (:* a-whitestuff)))
    (a-whitestuff (:or a-whitechar a-comment))
    (a-whitechar (:or a-newline a-vertab a-space a-tab))
    (a-newline (:or (:: a-return a-linefeed) a-return a-linefeed a-formfeed))
    (a-return #\return)
    (a-linefeed #\newline)
    (a-formfeed #\page)
    (a-vertab #\vtab)
    (a-space #\space)
    (a-tab #\tab)
    (a-comment (:: a-dashes (:? (:- a-any a-symbol) (:* a-any)) a-newline))
    (a-dashes (:: "--" (:* "-")))
    (a-any (:or a-graphic a-space a-tab))
    (a-opencom "{-")
    (a-ANY (:or a-graphic a-whitechar))
    (a-closecom "-}")
    (a-exponent (:: (:or "e" "E") (:? (:or "+" "-")) a-decimal))
    (a-decimal (:: a-digit (:* a-digit)))
    (a-digit (:/ #\0 #\9))
    (a-octal (:: a-octit (:* a-octit)))
    (a-octit (:/ #\0 #\7))
    (a-hexadecimal (:: a-hexit (:* a-hexit)))
    (a-hexit (:or a-digit (:/ #\A #\F) (:/ #\a #\f)))
    (a-graphic (:or a-small a-large a-symbol a-digit a-special ":" #\" "'"))
    (a-small (:or (:/ #\a #\z) "_"))
    (a-large (:or (:/ #\A #\Z)))
    (a-symbol (:or "~" "!" "@" "#" "$" "%" "^" "&" "*" "-" "+" "=" #\\ "|" "." "/" "<" ">" "?"))
    (a-special (:or "(" ")" "," ";" "[" "]" "`" "{" "}"))
    (a-escape (:: #\\ (:or a-charesc a-ascii a-decimal (:: "o" a-octal) (:: "x" a-hexadecimal))))
    (a-charesc (:or "a" "b" "f" "n" "r" "t" "v" #\\ #\" "'" "&"))
    (a-ascii (:or (:: "^" a-cntrl) "NUL" "SOH" "STX" "ETX" "EOT" "ENQ" "ACK" "BEL" "BS" "HT" "LF" "VT" "FF" "CR" "SO" "SI" "DLE" "DC1" "DC2" "DC3" "DC4" "NAK" "SYN" "ETB" "CAN" "EM" "SUB" "ESC" "FS" "GS" "RS" "US" "SP" "DEL"))
    (a-cntrl (:or a-large "@" "[" #\\ "]" "^" "_"))
    (a-gap (:: #\\ a-whitechar (:* a-whitechar) #\\))
    (a-reservedid (:or "case" "class" "data" "default" "deriving" "do" "else" "if" "import" "in" "infix" "infixl" "infixr" "instance" "let" "module" "newtype" "of" "then" "type" "where" "_"))
    (a-reservedop (:or ":" "::" "=" #\\ "|" "->"))
    (a-conid (:: a-large (:* (:or a-small a-large a-digit "'"))))
    (a-qualifier (:+ (:: a-conid ".")))
    (a-consym (:- (:: ":" (:* (:or a-symbol ":"))) a-reservedop))
    (a-varid (:- (:: a-small (:* (:or a-small a-large a-digit "'"))) a-reservedid))
    (a-varsym (:- (:: a-symbol (:* (:or a-symbol ":"))) (:or a-reservedop a-dashes))))
  
  (define-empty-tokens keywords (eof t-backslash t-backtick t-case t-colon t-coloncolon t-comma t-data t-else t-equal t-hiding t-if t-import t-in t-lcbracket t-let t-lrbracket t-lsbracket t-ml t-module t-of t-pipe t-rcbracket t-rrbracket t-rsbracket t-singlearrow t-scheme t-semicolon t-then t-underscore t-where))
  
  (define-tokens regular (t-char t-conid t-consym t-float t-integer t-qconid t-qconsym t-qlistcon t-qvarid t-qvarsym t-string t-varid t-varsym))
  
  (define languageLexer
    (lexer-src-pos (#\\ (token-t-backslash))
                   ("`" (token-t-backtick))
                   ("case" (token-t-case))
                   (":" (token-t-colon))
                   ("::" (token-t-coloncolon))
                   ("," (token-t-comma))
                   ("data" (token-t-data))
                   ("else" (token-t-else))
                   ("=" (token-t-equal))
                   ("if" (token-t-if))
                   ("import" (token-t-import))
                   ("in" (token-t-in))
                   ("{" (token-t-lcbracket))
                   ("let" (token-t-let))
                   ("(" (token-t-lrbracket))
                   ("[" (token-t-lsbracket))
                   (":ml" (token-t-ml))
                   ("module" (token-t-module))
                   ("of" (token-t-of))
                   ("|" (token-t-pipe))
                   ("}" (token-t-rcbracket))
                   (")" (token-t-rrbracket))
                   ("]" (token-t-rsbracket))
                   ("->" (token-t-singlearrow))
                   (":scheme" (token-t-scheme))
                   (";" (token-t-semicolon))
                   ("then" (token-t-then))
                   ("_" (token-t-underscore))
                   ("where" (token-t-where))
                   ((:: "'" (:or (:- a-graphic (:or "'" #\\)) a-space (:- a-escape (:: #\\ "&"))) "'") (token-t-char (substring lexeme 1 (- (string-length lexeme) 1))))
                   (a-conid (token-t-conid lexeme))
                   ((:: a-qualifier a-conid) (token-t-qconid lexeme))
                   (a-consym (token-t-consym lexeme))
                   ((:: a-qualifier a-consym) (token-t-qconsym lexeme))
                   ((:: a-decimal "." a-decimal (:? a-exponent)) (token-t-float lexeme))
                   ((:or a-decimal (:: "0o" a-octal) (:: "0O" a-octal) (:: "0x" a-hexadecimal) (:: "0X" a-hexadecimal)) (token-t-integer lexeme))
                   ((:: a-qualifier ":") (token-t-qlistcon lexeme))
                   (a-varid (token-t-varid lexeme))
                   ((:: a-qualifier a-varid) (token-t-qvarid lexeme))
                   (a-varsym (token-t-varsym lexeme))
                   ((:: a-qualifier a-varsym) (token-t-qvarsym lexeme))
                   (#\" (token-t-string (string-lexer input-port)))
                   (a-whitespace (return-without-pos (languageLexer input-port)))
                   (a-opencom (return-without-pos ((comment-lexer 1) input-port)))
                   (a-closecom (raise-read-error (format "Parsing: Unexpected comment close (~a:~a)"
                                                         (position-line start-pos)
                                                         (position-col start-pos))
                                                 "unknown"
                                                 (position-line start-pos)
                                                 (position-col start-pos)
                                                 (position-offset start-pos)
                                                 (- (position-offset end-pos) (position-offset start-pos))))
                   ((eof) (token-eof))))
  
  (define string-lexer
    (lexer ((:or (:- a-graphic (:or #\" #\\)) a-space a-escape) (cons (make-Character lexeme) (string-lexer input-port)))
           (a-gap (string-lexer input-port))
           (#\" null)
           ((eof) (raise-read-error (format "Parsing: Unexpected end of file (~a:~a)"
                                            (position-line start-pos)
                                            (position-col start-pos))
                                    "unknown"
                                    (position-line start-pos)
                                    (position-col start-pos)
                                    (position-offset start-pos)
                                    (- (position-offset end-pos) (position-offset start-pos))))))
  
  (define (comment-lexer level)
    (lexer (a-opencom ((comment-lexer (+ level 1)) input-port))
           (a-closecom (if (= level 1) (languageLexer input-port) ((comment-lexer (- level 1)) input-port)))
           (a-ANY ((comment-lexer level) input-port))
           ((eof) (raise-read-error (format "Parsing: Unexpected end of file (~a:~a)"
                                            (position-line start-pos)
                                            (position-col start-pos))
                                    "unknown"
                                    (position-line start-pos)
                                    (position-col start-pos)
                                    (position-offset start-pos)
                                    (- (position-offset end-pos) (position-offset start-pos))))))
  
  (define (charsToString chars)
    (foldr (lambda (x y) (string-append (Character-value x) y)) "" chars))
  
  (define (checkToken expected actual)
    (if (foldl (lambda (x y) (or x y)) #f (map (lambda (x) (equal? actual x)) expected))
        actual
        (error (format "Parsing: Expected ~a and found '~a'"
                       (foldl string-append "" (add-between (map (lambda (x) (string-append "'" x "'")) expected) " or "))
                       actual))))
  
  (define (languageParsers source-name)
    (parser (src-pos)
            (tokens keywords regular)
            (start nt-exp nt-impdecl nt-module nt-topdecl nt-type)
            (end eof)
            (error (lambda (token-ok token-name token-value start-pos end-pos)
                     (raise-read-error (format "Parsing: Found an unexpected ~a in '~a' at line ~a and column ~a"
                                               token-name
                                               source-name
                                               (position-line start-pos)
                                               (position-col start-pos)
                                               )
                                       source-name
                                       (position-line start-pos)
                                       (position-col start-pos)
                                       (position-offset start-pos)
                                       (- (position-offset end-pos) (position-offset start-pos)))))
            (grammar (nt-module ((t-module nt-modid nt-exports t-where nt-body) (make-Module $2 $3 (list-ref $5 0) (list-ref $5 1))))
                     (nt-modid ((t-conid) $1)
                               ((t-qconid) $1))
                     (nt-qmodid ((t-conid) $1)
                                ((t-qconid) $1))
                     (nt-exports ((t-lrbracket nt-exports-2 t-rrbracket) (make-Just $2))
                                 (() (make-Nothing)))
                     (nt-exports-2 ((nt-exports-3) $1)
                                   (() null))
                     (nt-exports-3 ((nt-export t-comma nt-exports-3) (cons $1 $3))
                                   ((nt-export) (list $1)))
                     (nt-export ((nt-cname) $1))
                     (nt-body ((t-lcbracket nt-impdecls t-semicolon nt-topdecls t-rcbracket) (list $2 $4))
                              ((t-lcbracket nt-impdecls t-rcbracket) (list $2 null))
                              ((t-lcbracket nt-topdecls t-rcbracket) (list null $2)))
                     (nt-impdecls ((nt-impdecls t-semicolon nt-impdecl) (cons $3 $1))
                                  ((nt-impdecl) (list $1)))
                     (nt-impdecl ((t-import t-varid nt-qmodid t-lrbracket nt-imports t-rrbracket)
                                  (make-Impdecl (checkToken (list "haskell" "ml" "scheme") $2) $3 $5)))
                     (nt-imports ((nt-impguard t-comma nt-imports) (cons $1 $3))
                                 ((nt-impguard) (list $1)))
                     (nt-impguard ((nt-import t-coloncolon nt-type) (make-Import $1 $3)))
                     (nt-import ((nt-cname) $1))
                     (nt-cname ((nt-var) $1)
                               ((nt-con) $1)
                               ((t-lrbracket t-colon t-rrbracket) ":"))
                     (nt-qcname ((nt-qvar) $1)
                                ((nt-qcon) $1)
                                ((t-lrbracket t-qlistcon t-rrbracket) $2))
                     (nt-topdecls (() null)
                                  ((nt-topdecl nt-topdecls-2) (cons $1 $2)))
                     (nt-topdecls-2 (() null)
                                    ((t-semicolon nt-topdecl nt-topdecls-2) (cons $2 $3)))
                     (nt-topdecl ((t-data nt-simpletype nt-topdecl-2 t-equal nt-constrs) (make-Data $2 $3 $5))
                                 ((nt-decl) $1))
                     (nt-topdecl-2 (() null)
                                   ((nt-tyvar nt-topdecl-2) (cons $1 $2)))
                     (nt-simpletype ((nt-tycon) $1))
                     (nt-constrs ((nt-constr nt-constrs-2) (cons $1 $2)))
                     (nt-constrs-2 (() null)
                                   ((t-pipe nt-constr nt-constrs-2) (cons $2 $3)))
                     (nt-constr ((nt-con nt-constr-2) (make-Constructor $1 $2)))
                     (nt-constr-2 (() null)
                                  ((t-lcbracket nt-constr-3 t-rcbracket) $2))
                     (nt-constr-3 (() null)
                                  ((nt-fielddecl nt-constr-4) (append $1 $2)))
                     (nt-constr-4 (() null)
                                  ((t-comma nt-fielddecl nt-constr-4) (append $2 $3)))
                     (nt-fielddecl ((nt-vars t-coloncolon nt-type) (map (lambda (x) (make-Field x $3)) $1)))
                     (nt-decls ((t-lcbracket nt-decls-2 t-rcbracket) $2))
                     (nt-decls-2 (() null)
                                 ((nt-decl nt-decls-3) (cons $1 $2)))
                     (nt-decls-3 (() null)
                                 ((t-semicolon nt-decl nt-decls-3) (cons $2 $3)))
                     (nt-decl ((nt-funlhs nt-rhs) (make-Declaration $1 $2)))
                     (nt-funlhs ((nt-var nt-funlhs-2) (make-LHS $1 $2))
                                ((nt-apat nt-varop nt-apat) (make-LHS $2 (list $1 $3))))
                     (nt-funlhs-2 (() null)
                                  ((nt-apat nt-funlhs-2) (cons $1 $2)))
                     (nt-vars ((nt-var nt-vars-2) (cons $1 $2)))
                     (nt-vars-2 (() null)
                                ((t-comma nt-var nt-vars-2) (cons $2 $3)))
                     (nt-varop ((t-varsym) $1)
                               ((t-backtick t-varid t-backtick) $2))
                     (nt-rhs ((t-equal nt-exp) $2))
                     (nt-exp ((t-backslash nt-exp-2 t-singlearrow nt-exp) (make-Function $2 $4))
                             ((t-let nt-decls t-in nt-exp) (make-Let $2 $4))
                             ((t-if nt-exp t-then nt-exp t-else nt-exp) (make-If $2 $4 $6))
                             ((nt-fexp) $1))
                     (nt-exp-2 ((nt-apat) (list $1))
                               ((nt-apat nt-exp-2) (cons $1 $2)))
                     (nt-fexp ((nt-fexp-2 nt-aexp) (if (null? $1) $2 (make-Application $1 $2))))
                     (nt-fexp-2 (() null)
                                ((nt-fexp) $1))
                     (nt-aexp ((nt-qvar) (make-Variable $1))
                              ((nt-gcon) $1)
                              ((nt-literal) $1)
                              ((t-lrbracket nt-exp t-rrbracket) $2)
                              ((t-lrbracket nt-exp t-comma nt-exp nt-aexp-2 t-rrbracket) (make-Tuple (cons $2 (cons $4 $5))))
                              ((t-lsbracket nt-exp nt-aexp-2 t-rsbracket) (make-List (cons $2 $3))))
                     (nt-aexp-2 (() null)
                                ((t-comma nt-exp nt-aexp-2) (cons $2 $3)))
                     (nt-var ((t-varid) $1)
                             ((t-lrbracket t-varsym t-rrbracket) $2))
                     (nt-qvar ((t-varid) $1)
                              ((t-qvarid) $1)
                              ((t-lrbracket t-varsym t-rrbracket) $2)
                              ((t-lrbracket t-qvarsym t-rrbracket) $2)
                              ((t-lrbracket t-qlistcon t-rrbracket) $2))
                     (nt-gcon ((t-lrbracket t-rrbracket) (make-UnitConstructor))
                              ((t-lsbracket t-rsbracket) (make-ListConstructor))
                              ((t-lrbracket t-comma nt-gcon-2 t-rrbracket) (make-TupleConstructor (+ $3 2)))
                              ((nt-qcon) (make-Variable $1)))
                     (nt-gcon-2 (() 0)
                                ((t-comma nt-gcon-2) (+ $2 1)))
                     (nt-con ((t-conid) $1)
                             ((t-lrbracket t-consym t-rrbracket) $2))
                     (nt-qcon ((t-conid) $1)
                              ((t-qconid) $1)
                              ((t-lrbracket nt-gconsym t-rrbracket) $2))
                     (nt-gconsym ((t-colon) ":")
                                 ((t-consym) $1)
                                 ((t-qconsym) $1))
                     (nt-literal ((t-integer) (make-Integer $1))
                                 ((t-float) (make-Float $1))
                                 ((t-char) (make-Character $1))
                                 ((t-string) (make-List $1)))
                     (nt-apat ((nt-var) $1))
                     (nt-type ((nt-btype) $1)
                              ((nt-btype t-singlearrow nt-type) (t/make-Application (t/make-Application (t/make-Function) $1) $3)))
                     (nt-btype ((nt-atype) $1)
                               ((nt-btype nt-atype) (t/make-Application $1 $2)))
                     (nt-atype ((nt-gtycon) $1)
                               ((nt-tyvar) (t/make-Variable $1))
                               ((t-lrbracket nt-type t-comma nt-atype-2 t-rrbracket)
                                (let ((types (cons $2 $4)))
                                  (foldl (lambda (x y) (t/make-Application y x)) (t/make-Tuple (length types)) types)))
                               ((t-lsbracket nt-type t-rsbracket) (t/make-Application (t/make-List) $2))
                               ((t-lrbracket nt-type t-rrbracket) $2))
                     (nt-atype-2 ((nt-type t-comma nt-atype-2) (cons $1 $3))
                                 ((nt-type) (list $1)))
                     (nt-gtycon ((nt-qtycon) (t/make-Constructor $1))
                                ((t-lrbracket t-rrbracket) (t/make-Unit))
                                ((t-lsbracket t-rsbracket) (t/make-List))
                                ((t-lrbracket t-singlearrow t-rrbracket) (t/make-Function))
                                ((t-lrbracket nt-gtycon-2 t-rrbracket) (t/make-Tuple $2)))
                     (nt-gtycon-2 ((t-comma nt-gtycon-2) (+ 1 $2))
                                  ((t-comma) 1))
                     (nt-qtycon ((t-qconid) $1)
                                ((t-conid) $1))
                     (nt-tycon ((t-conid) $1))
                     (nt-tyvar ((t-varid) $1)))))
  
  (define (getParsers source)
    (zip (list 'expression 'import 'module 'declaration 'type) (languageParsers source)))
  
  (define (getParser name parsers)
    (let ((parser (Just-value (lookup name parsers))))
      (lambda (s)
        (let ((p (open-input-string s)))
          (port-count-lines! p)
          (parser (lambda () (languageLexer p))))))))