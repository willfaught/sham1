(module TypeCheckerTest mzscheme
  (require (lib "contract.ss")
           (planet "main.ss" ("schematics" "schemeunit.plt" 3 3))
           (only (lib "HaskellSyntax.ss" "sham" "haskell") HaskellSyntax?)
           (only (lib "Maybe.ss" "sham" "haskell") Nothing?)
           (only (lib "Parsers.ss" "sham" "haskell") expressionParser moduleParser typeParser)
           (only (lib "SyntaxTransformer.ss" "sham" "haskell") transformHC)
           (only (lib "TypeChecker.ss" "sham" "haskell") syntaxType wellTyped))
  
  (provide testSuite)
  
  (define/contract eit (-> string? string? test-case?)
    (lambda (name expression)
      (test-case name (check-exn exn? (lambda () (syntaxType (transformHC (parseE expression))))))))
  
  (define/contract ewt (-> string? string? string? test-case?)
    (lambda (name expression type)
      (test-case name (check-equal? (syntaxType (transformHC (parseE expression))) (transformHC (parseT type))))))
  
  (define/contract mit (-> string? string? test-case?)
    (lambda (name module)
      (test-case name (check-exn exn? (lambda () (wellTyped (transformHC (parseM module))))))))
  
  (define/contract mwt (-> string? string? test-case?)
    (lambda (name module)
      (test-case name (check-true (wellTyped (transformHC (parseM module)))))))
  
  (define/contract parseE (-> string? HaskellSyntax?) (expressionParser "test"))
  
  (define/contract parseM (-> string? HaskellSyntax?) (moduleParser "test"))
  
  (define/contract parseT (-> string? HaskellSyntax?) (typeParser "test"))
  
  (define/contract testSuite schemeunit-test-suite?
    (test-suite "TypeChecker"
                (ewt "ap1" "(\\x -> 1) 1" "Int")
                (ewt "ap2" "(\\x -> x) 1" "Int")
                (ewt "ap3" "(\\x -> \\y -> x) 1" "t -> Int")
                (ewt "ap4" "(\\x y -> x) 1" "t -> Int")
                (ewt "ap5" "(\\x -> [x]) 1" "[Int]")
                (ewt "ap6" "(\\x -> (x, x)) 1" "(Int, Int)")
                (ewt "ap7" "(\\x y -> 1) 2 3" "Int")
                (eit "ap8" "1 2")
                (eit "ap9" "(\\x -> x) 1 2")
                (eit "ap10" "let { i x = x ; j = i 1 } in i 'a'")
                (ewt "ch1" "'a'" "Char")
                (mwt "da1" "{}")
                (mwt "da2" "{ data A = A { a :: A } | B { b :: A } | C ; c = B (A (B C)) }")
                (mit "da3" "{ data A = A { a :: A } | B { b :: A } | C ; c = A 1 }")
                (mit "da4" "{ data A = A { a :: A } | B { b :: A } | C ; c = B 1 }")
                (mit "da5" "{ data A = A { a :: A } | B { b :: A } | C ; c = C 1 }")
                (mit "da6" "{ data A = A { a :: A } | B { b :: A } | C ; c = A B }")
                (mit "da7" "{ data A = A { a :: A } | B { b :: A } | C ; c = B A }")
                (mwt "da8" "{ data A = A { a :: A } | B { b :: A } | C ; c = a (b (a (A (B (A C))))) ; d = a C ; e = b C }")
                (mit "da9" "{ data A = A { a :: A } | B { b :: A } | C ; c = a 1 }")
                (mit "da10" "{ data A = A { a :: A } | B { b :: A } | C ; c = b 1 }")
                (mwt "da11" "{ data A = A { a :: A } | B { b :: A } | C ; c = isA (A C) ; d = isA (B C) ; e = isA C }")
                (mwt "da12" "{ data A = A { a :: A } | B { b :: A } | C ; c = isB (A C) ; d = isB (B C) ; e = isB C }")
                (mwt "da13" "{ data A = A { a :: A } | B { b :: A } | C ; c = isC (A C) ; d = isC (B C) ; e = isC C }")
                (mit "da14" "{ data A = A { a :: A } | B { b :: A } | C ; c = isA 1 }")
                (mit "da15" "{ data A = A { a :: A } | B { b :: A } | C ; c = isB 1 }")
                (mit "da16" "{ data A = A { a :: A } | B { b :: A } | C ; c = isC 1 }")
                (mwt "da17" "{ data A = A { a :: B } | B ; data B = C { b :: A } | D ; c = A (C B) ; d = A D ; e = C (A D) ; f = C B }")
                (ewt "fl1" "1.2" "Float")
                (ewt "fu1" "\\x -> 1" "t -> Int")
                (ewt "fu2" "\\x -> x" "t -> t")
                (ewt "fu3" "\\x -> \\y -> x" "t -> t1 -> t")
                (ewt "fu4" "\\x y -> x" "t -> t1 -> t")
                (ewt "fu5" "\\x -> \\y -> y" "t -> t1 -> t1")
                (ewt "fu6" "\\x y -> y" "t -> t1 -> t1")
                (ewt "fu7" "\\x -> [x]" "t -> [t]")
                (ewt "fu8" "\\x -> (x, x)" "t -> (t, t)")
                (eit "id1" "x")
                (ewt "id2" "error" "[Char] -> t")
                (ewt "id3" "fst" "(t, t1) -> t")
                (ewt "id4" "head" "[t] -> t")
                (ewt "id5" "isFalse" "Bool -> Bool")
                (ewt "id6" "isTrue" "Bool -> Bool")
                (ewt "id7" "null" "[t] -> Bool")
                (ewt "id8" "snd" "(t, t1) -> t1")
                (ewt "id9" "tail" "[t] -> [t]")
                (ewt "id10" "False" "Bool")
                (ewt "id11" "True" "Bool")
                (ewt "id12" "(:)" "t -> [t] -> [t]")
                (ewt "id13" "()" "()")
                (ewt "if1" "if True then 1 else 2" "Int")
                (eit "if2" "if 1 then 2 else 3")
                (eit "if3" "if True then 1 else 'a'")
                (ewt "in1" "1" "Int")
                (ewt "le1" "let { i = 1 } in 2.3" "Float")
                (ewt "le2" "let { i = 1 } in i" "Int")
                (ewt "le3" "let { i = i } in i" "t")
                (ewt "le4" "let { i = 2 ; j = i } in j" "Int")
                (ewt "le5" "let { i = j ; j = 2 } in j" "Int")
                (ewt "le6" "let { i x = 2 } in i" "t -> Int")
                (ewt "le7" "let { i x = x } in i" "t -> t")
                (ewt "le8" "let { i x y = y } in i" "t -> t1 -> t1")
                (ewt "le9" "let { i x = x ; j = i 2; k = i 3 } in i" "Int -> Int")
                (ewt "le10" "let { i x = 2 } in i 3" "Int")
                (ewt "le11" "let { i x = x } in i 2" "Int")
                (ewt "le12" "let { i x = x } in let { j = i 2 ; k = i 3.4 } in i" "t -> t")
                (ewt "le13" "let { i x = x } in let { j = i 2 ; k = i 3.4 } in j" "Int")
                (eit "le16" "let { i = [i] } in i")
                (eit "le17" "let { i = (i, i) } in i")
                (eit "le18" "let { i x = x ; j = i 1 ; k = i 2.3 } in i")
                (ewt "li1" "[]" "[t]")
                (ewt "li2" "[1]" "[Int]")
                (ewt "li3" "\"\"" "[t]")
                (ewt "li4" "\"foo\"" "[Char]")
                (eit "li5" "[1, 'a']")
                (ewt "ml1" ":ml Int \"x\"" "Int")
                (ewt "ml2" ":ml a -> a \"x\"" "t -> t")
                (mwt "mo1" "{}")
                (mwt "mo2" "{ i = 1 }")
                (mwt "mo3" "{ i = i }")
                (mwt "mo4" "{ i x = 1 }")
                (mwt "mo5" "{ i x = x }")
                (mwt "mo6" "{ i x y = x }")
                (mwt "mo7" "{ i = 1 ; j = i }")
                (mwt "mo8" "{ i = j ; j = 1 }")
                (mwt "mo9" "{ i = j ; j = i }")
                (mwt "mo10" "{ i = 1 ; j = i }")
                (mwt "mo11" "{ i x = x ; j = i 1 }")
                (mit "mo12" "{ i = 1 ; j = i 2 }")
                (mit "mo13" "{ i x = x ; j = i 1 2 }")
                (mwt "mo14" "{ i x = x ; j = i 1 ; k = 2 }")
                (mit "mo15" "{ i x = x ; j = i 1 ; k = i 'a' }")
                (mwt "mo16" "{ i = let { i x = x } in i ; j = i 1 }")
                (mit "mo17" "{ i = [i] }")
                (mit "mo18" "{ i = (i, i) }")
                (ewt "sc1" ":scheme Int \"x\"" "Int")
                (ewt "sc2" ":scheme a -> a \"x\"" "t -> t")
                (ewt "tu1" "('a', 1)" "(Char, Int)")
                (ewt "tu2" "('b', 1, 1)" "(Char, Int, Int)")
                (ewt "tc1" "(,)" "t -> t1 -> (t, t1)")
                (ewt "tc2" "(,,)" "t -> t1 -> t2 -> (t, t1, t2)")
                (ewt "tc3" "(,) 1" "t -> (Int, t)")
                (ewt "tc4" "(,) 1 2" "(Int, Int)")
                (ewt "tc5" "(,,) 1" "t -> t1 -> (Int, t, t1)")
                (ewt "tc6" "(,,) 1 2" "t -> (Int, Int, t)")
                (ewt "tc7" "(,,) 1 2 3" "(Int, Int, Int)")
                (eit "tc8" "(,) 1 2 3")
                (eit "tc9" "(,,) 1 2 3 4"))))
