(module TypeCheckerTest mzscheme
  (require (lib "match.ss")
           (planet "test.ss" ("schematics" "schemeunit.plt" 2))
           (only (lib "Parsers.ss" "sham" "haskell") declarationParser expressionParser moduleParser typeParser)
           (only (lib "SyntaxTransformer.ss" "sham" "haskell") transformHC)
           (only (lib "TypeChecker.ss" "sham" "haskell") moduleContext syntaxType)
           (lib "Types.ss" "sham"))
  
  (provide testSuite)
  
  ; ee :: string string string -> test-case
  (define (ee name expression type)
    (test-equal? name (syntaxType null (transformHC (parseE expression))) (transformHC (parseT type))))
  
  ; ex :: string string -> test-case
  (define (ex name expression)
    (test-exn name (lambda (x) #t) (lambda () (syntaxType null (transformHC (parseE expression))))))
  
  ; mnx :: string string -> test-case
  (define (mnx name module)
    (test-not-exn name (lambda () (moduleContext null (transformHC (parseM module))))))
  
  ; mx :: string string -> test-case
  (define (mx name module)
    (test-exn name (lambda (x) #t) (lambda () (moduleContext null (transformHC (parseM module))))))
  
  ; parseD :: string -> HaskellSyntax
  (define parseD (declarationParser "test"))
  
  ; parseE :: string -> HaskellSyntax
  (define parseE (expressionParser "test"))
  
  ; parseM :: string -> HaskellSyntax
  (define parseM (moduleParser "test"))
  
  ; parseT :: string -> HaskellSyntax
  (define parseT (typeParser "test"))
  
  ; testSuite :: schemeunit-test-suite
  (define testSuite
    (test-suite "TypeChecker"
                (ee "ap1" "(\\x -> 1) 1" "Int")
                (ee "ap2" "(\\x -> x) 1" "Int")
                (ee "ap3" "(\\x -> \\y -> x) 1" "t -> Int")
                (ee "ap4" "(\\x y -> x) 1" "t -> Int")
                (ee "ap5" "(\\x -> [x]) 1" "[Int]")
                (ee "ap6" "(\\x -> (x, x)) 1" "(Int, Int)")
                (ee "ap7" "(\\x y -> 1) 2 3" "Int")
                (ex "ap8" "1 2")
                (ex "ap9" "(\\x -> x) 1 2")
                (ex "ap10" "let { i x = x ; j = i 1 } in i 'a'")
                (ee "ch1" "'a'" "Char")
                (mnx "da1" "{}")
                (mnx "da2" "{ data A = A { a :: A } | B { b :: A } | C ; c = B (A (B C)) }")
                (mx "da3" "{ data A = A { a :: A } | B { b :: A } | C ; c = A 1 }")
                (mx "da4" "{ data A = A { a :: A } | B { b :: A } | C ; c = B 1 }")
                (mx "da5" "{ data A = A { a :: A } | B { b :: A } | C ; c = C 1 }")
                (mx "da6" "{ data A = A { a :: A } | B { b :: A } | C ; c = A B }")
                (mx "da7" "{ data A = A { a :: A } | B { b :: A } | C ; c = B A }")
                (mnx "da8" "{ data A = A { a :: A } | B { b :: A } | C ; c = a (b (a (A (B (A C))))) ; d = a C ; e = b C }")
                (mx "da9" "{ data A = A { a :: A } | B { b :: A } | C ; c = a 1 }")
                (mx "da10" "{ data A = A { a :: A } | B { b :: A } | C ; c = b 1 }")
                (mnx "da11" "{ data A = A { a :: A } | B { b :: A } | C ; c = isA (A C) ; d = isA (B C) ; e = isA C }")
                (mnx "da12" "{ data A = A { a :: A } | B { b :: A } | C ; c = isB (A C) ; d = isB (B C) ; e = isB C }")
                (mnx "da13" "{ data A = A { a :: A } | B { b :: A } | C ; c = isC (A C) ; d = isC (B C) ; e = isC C }")
                (mx "da14" "{ data A = A { a :: A } | B { b :: A } | C ; c = isA 1 }")
                (mx "da15" "{ data A = A { a :: A } | B { b :: A } | C ; c = isB 1 }")
                (mx "da16" "{ data A = A { a :: A } | B { b :: A } | C ; c = isC 1 }")
                (mnx "da17" "{ data A = A { a :: B } | B ; data B = C { b :: A } | D ; c = A (C B) ; d = A D ; e = C (A D) ; f = C B }")
                (ee "fl1" "1.2" "Float")
                (ee "fu1" "\\x -> 1" "t -> Int")
                (ee "fu2" "\\x -> x" "t -> t")
                (ee "fu3" "\\x -> \\y -> x" "t -> t1 -> t")
                (ee "fu4" "\\x y -> x" "t -> t1 -> t")
                (ee "fu5" "\\x -> \\y -> y" "t -> t1 -> t1")
                (ee "fu6" "\\x y -> y" "t -> t1 -> t1")
                (ee "fu7" "\\x -> [x]" "t -> [t]")
                (ee "fu8" "\\x -> (x, x)" "t -> (t, t)")
                (ex "id1" "x")
                (ee "id2" "error" "[Char] -> t")
                (ee "id3" "fst" "(t, t1) -> t")
                (ee "id4" "head" "[t] -> t")
                (ee "id5" "isFalse" "Bool -> Bool")
                (ee "id6" "isTrue" "Bool -> Bool")
                (ee "id7" "null" "[t] -> Bool")
                (ee "id8" "snd" "(t, t1) -> t1")
                (ee "id9" "tail" "[t] -> [t]")
                (ee "id10" "False" "Bool")
                (ee "id11" "True" "Bool")
                (ee "id12" "(:)" "t -> [t] -> [t]")
                (ee "id13" "()" "()")
                (ee "if1" "if True then 1 else 2" "Int")
                (ex "if2" "if 1 then 2 else 3")
                (ex "if3" "if True then 1 else 'a'")
                (ee "in1" "1" "Int")
                (ee "le1" "let { i = 1 } in 2.3" "Float")
                (ee "le2" "let { i = 1 } in i" "Int")
                (ee "le3" "let { i = i } in i" "t")
                (ee "le4" "let { i = 2 ; j = i } in j" "Int")
                (ee "le5" "let { i = j ; j = 2 } in j" "Int")
                (ee "le6" "let { i x = 2 } in i" "t -> Int")
                (ee "le7" "let { i x = x } in i" "t -> t")
                (ee "le8" "let { i x y = y } in i" "t -> t1 -> t1")
                (ee "le9" "let { i x = x ; j = i 2; k = i 3 } in i" "Int -> Int")
                (ee "le10" "let { i x = 2 } in i 3" "Int")
                (ee "le11" "let { i x = x } in i 2" "Int")
                (ee "le12" "let { i x = x } in let { j = i 2 ; k = i 3.4 } in i" "t -> t")
                (ee "le13" "let { i x = x } in let { j = i 2 ; k = i 3.4 } in j" "Int")
                (ex "le16" "let { i = [i] } in i")
                (ex "le17" "let { i = (i, i) } in i")
                (ex "le18" "let { i x = x ; j = i 1 ; k = i 2.3 } in i")
                (ee "li1" "[]" "[t]")
                (ee "li2" "[1]" "[Int]")
                (ee "li3" "\"\"" "[t]")
                (ee "li4" "\"foo\"" "[Char]")
                (ex "li5" "[1, 'a']")
                (ee "ml1" ":ml Int \"x\"" "Int")
                (ee "ml2" ":ml a -> a \"x\"" "t -> t")
                (mnx "mo1" "{}")
                (mnx "mo2" "{ i = 1 }")
                (mnx "mo3" "{ i = i }")
                (mnx "mo4" "{ i x = 1 }")
                (mnx "mo5" "{ i x = x }")
                (mnx "mo6" "{ i x y = x }")
                (mnx "mo7" "{ i = 1 ; j = i }")
                (mnx "mo8" "{ i = j ; j = 1 }")
                (mnx "mo9" "{ i = j ; j = i }")
                (mnx "mo10" "{ i = 1 ; j = i }")
                (mnx "mo11" "{ i x = x ; j = i 1 }")
                (mx "mo12" "{ i = 1 ; j = i 2 }")
                (mx "mo13" "{ i x = x ; j = i 1 2 }")
                (mnx "mo14" "{ i x = x ; j = i 1 ; k = 2 }")
                (mx "mo15" "{ i x = x ; j = i 1 ; k = i 'a' }")
                (mnx "mo16" "{ i = let { i x = x } in i ; j = i 1 }")
                (mx "mo17" "{ i = [i] }")
                (mx "mo18" "{ i = (i, i) }")
                (ee "sc1" ":scheme Int \"x\"" "Int")
                (ee "sc2" ":scheme a -> a \"x\"" "t -> t")
                (ee "tu1" "('a', 1)" "(Char, Int)")
                (ee "tu2" "('b', 1, 1)" "(Char, Int, Int)")
                (ee "tc1" "(,)" "t -> t1 -> (t, t1)")
                (ee "tc2" "(,,)" "t -> t1 -> t2 -> (t, t1, t2)")
                (ee "tc3" "(,) 1" "t -> (Int, t)")
                (ee "tc4" "(,) 1 2" "(Int, Int)")
                (ee "tc5" "(,,) 1" "t -> t1 -> (Int, t, t1)")
                (ee "tc6" "(,,) 1 2" "t -> (Int, Int, t)")
                (ee "tc7" "(,,) 1 2 3" "(Int, Int, Int)")
                (ex "tc8" "(,) 1 2 3")
                (ex "tc9" "(,,) 1 2 3 4"))))