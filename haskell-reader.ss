(module haskell-reader mzscheme
  (require (lib "lex.ss" "parser-tools")
           (prefix : (lib "lex-sre.ss" "parser-tools"))
           (lib "yacc.ss" "parser-tools")
           (lib "readerr.ss" "syntax")
           (lib "list.ss")
           (lib "haskell-compiler.ss" "hs")
           (lib "haskell-terms.ss" "hs")
           (lib "haskell-typechecker.ss" "hs")
           (lib "haskell-types.ss" "hs"))
  
  (provide (rename read-haskell-syntax read-syntax))
  
  (define-lex-abbrevs
    (a-whitespace (:: a-whitestuff (:* a-whitestuff)))
    (a-whitestuff (:or a-whitechar a-comment))
    (a-whitechar (:or a-newline a-vertab a-space a-tab))
    (a-newline (:or (:: a-return a-linefeed) a-return a-linefeed a-formfeed))
    (a-return #\return)
    (a-linefeed #\newline)
    (a-formfeed #\page)
    (a-vertab #\vtab)
    (a-space #\space)
    (a-tab #\tab)
    (a-comment (:: a-dashes (:? (:- a-any a-symbol) (:* a-any)) a-newline))
    (a-dashes (:: "--" (:* "-")))
    (a-any (:or a-graphic a-space a-tab))
    (a-opencom "{-")
    (a-ANY (:or a-graphic a-whitechar))
    (a-closecom "-}")
    (a-exponent (:: (:or "e" "E") (:? (:or "+" "-")) a-decimal))
    (a-decimal (:: a-digit (:* a-digit)))
    (a-digit (:/ #\0 #\9))
    (a-octal (:: a-octit (:* a-octit)))
    (a-octit (:/ #\0 #\7))
    (a-hexadecimal (:: a-hexit (:* a-hexit)))
    (a-hexit (:or a-digit (:/ #\A #\F) (:/ #\a #\f)))
    (a-graphic (:or a-small a-large a-symbol a-digit a-special ":" #\" "'"))
    (a-small (:or (:/ #\a #\z) "_"))
    (a-large (:or (:/ #\A #\Z)))
    (a-symbol (:or "~" "!" "@" "#" "$" "%" "^" "&" "*" "-" "+" "=" #\\ "|" "." "/" "<" ">" "?"))
    (a-special (:or "(" ")" "," ";" "[" "]" "`" "{" "}"))
    (a-escape (:: #\\ (:or a-charesc a-ascii a-decimal (:: "o" a-octal) (:: "x" a-hexadecimal))))
    (a-charesc (:or "a" "b" "f" "n" "r" "t" "v" #\\ #\" "'" "&"))
    (a-ascii (:or (:: "^" a-cntrl) "NUL" "SOH" "STX" "ETX" "EOT" "ENQ" "ACK" "BEL" "BS" "HT" "LF" "VT" "FF" "CR" "SO" "SI" "DLE" "DC1" "DC2" "DC3" "DC4" "NAK" "SYN" "ETB" "CAN" "EM" "SUB" "ESC" "FS" "GS" "RS" "US" "SP" "DEL"))
    (a-cntrl (:or a-large "@" "[" #\\ "]" "^" "_"))
    (a-gap (:: #\\ a-whitechar (:* a-whitechar) #\\))
    (a-reservedid (:or "case" "class" "data" "default" "deriving" "do" "else" "if" "import" "in" "infix" "infixl" "infixr" "instance" "let" "module" "newtype" "of" "then" "type" "where" "_"))
    (a-reservedop (:or ":" "::" "=" #\\ "|" "->")))
  
  (define-empty-tokens keywords (eof t-backslash t-backtick t-case t-colon t-coloncolon t-comma t-else t-equal t-if t-import t-in t-lcbracket t-let t-lrbracket t-lsbracket t-module t-of t-rbracketcon t-rcbracket t-rrbracket t-rsbracket t-singlearrow t-sbracketcon t-semicolon t-then t-underscore t-where))
  
  (define-tokens regular (t-char t-conid t-consym t-float t-integer t-string t-varid t-varsym))
  
  (define haskell-lexer
    (lexer-src-pos (#\\ (token-t-backslash))
                   ("`" (token-t-backtick))
                   ("case" (token-t-case))
                   (":" (token-t-colon))
                   ("::" (token-t-coloncolon))
                   ("," (token-t-comma))
                   ("else" (token-t-else))
                   ("=" (token-t-equal))
                   ("if" (token-t-if))
                   ("import" (token-t-import))
                   ("in" (token-t-in))
                   ("{" (token-t-lcbracket))
                   ("let" (token-t-let))
                   ("(" (token-t-lrbracket))
                   ("[" (token-t-lsbracket))
                   ("module" (token-t-module))
                   ("of" (token-t-of))
                   ("()" (token-t-rbracketcon))
                   ("}" (token-t-rcbracket))
                   (")" (token-t-rrbracket))
                   ("]" (token-t-rsbracket))
                   ("->" (token-t-singlearrow))
                   ("[]" (token-t-sbracketcon))
                   (";" (token-t-semicolon))
                   ("then" (token-t-then))
                   ("_" (token-t-underscore))
                   ("where" (token-t-where))
                   ((:: "'" (:or (:- a-graphic (:or "'" #\\)) a-space (:- a-escape (:: #\\ "&"))) "'") (token-t-char (substring lexeme 1 (- (string-length lexeme) 1))))
                   ((:: a-large (:* (:or a-small a-large a-digit "'"))) (token-t-conid lexeme))
                   ((:- (:: ":" (:* (:or a-symbol ":"))) a-reservedop) (token-t-consym))
                   ((:: a-decimal "." a-decimal (:? a-exponent)) (token-t-float lexeme))
                   ((:or a-decimal (:: "0o" a-octal) (:: "0O" a-octal) (:: "0x" a-hexadecimal) (:: "0X" a-hexadecimal)) (token-t-integer lexeme))
                   (#\" (token-t-string (string-lexer input-port)))
                   ((:- (:: a-small (:* (:or a-small a-large a-digit "'"))) a-reservedid) (token-t-varid lexeme))
                   ((:- (:: a-symbol (:* (:or a-symbol ":"))) (:or a-reservedop a-dashes)) (token-t-varsym lexeme))
                   (a-whitespace (return-without-pos (haskell-lexer input-port)))
                   (a-opencom (return-without-pos ((comment-lexer 1) input-port)))
                   (a-closecom (raise-read-error (format "error: unexpected comment close (~a:~a)"
                                                         (position-line start-pos)
                                                         (position-col start-pos))
                                                 "unknown"
                                                 (position-line start-pos)
                                                 (position-col start-pos)
                                                 (position-offset start-pos)
                                                 (- (position-offset end-pos) (position-offset start-pos))))
                   ((eof) (token-eof))))
  
  (define string-lexer
    (lexer ((:or (:- a-graphic (:or #\" #\\)) a-space a-escape) (cons (make-character-term lexeme) (string-lexer input-port)))
           (a-gap (string-lexer input-port))
           (#\" null)
           ((eof) (raise-read-error (format "error: unexpected end of file (~a:~a)"
                                            (position-line start-pos)
                                            (position-col start-pos))
                                    "unknown"
                                    (position-line start-pos)
                                    (position-col start-pos)
                                    (position-offset start-pos)
                                    (- (position-offset end-pos) (position-offset start-pos))))))
  
  (define (comment-lexer level)
    (lexer (a-opencom ((comment-lexer (+ level 1)) input-port))
           (a-closecom (if (= level 1) (haskell-lexer input-port) ((comment-lexer (- level 1)) input-port)))
           (a-ANY ((comment-lexer level) input-port))
           ((eof) (raise-read-error (format "error: unexpected end of file (~a:~a)"
                                            (position-line start-pos)
                                            (position-col start-pos))
                                    "unknown"
                                    (position-line start-pos)
                                    (position-col start-pos)
                                    (position-offset start-pos)
                                    (- (position-offset end-pos) (position-offset start-pos))))))
  
  (define (haskell-parser source-name)
    (parser (src-pos)
            (tokens keywords regular)
            (start nt-module)
            (end eof)
            (error (lambda (token-ok token-name token-value start-pos end-pos)
                     (raise-read-error (format "error: malformed ~a (~a ~a:~a): ~a"
                                               token-name
                                               source-name
                                               (position-line start-pos)
                                               (position-col start-pos)
                                               token-value)
                                       source-name
                                       (position-line start-pos)
                                       (position-col start-pos)
                                       (position-offset start-pos)
                                       (- (position-offset end-pos) (position-offset start-pos)))))
            (grammar (nt-module ((t-module nt-modid t-where nt-body) (make-module-term $2 $4))
                                ((nt-body) (make-module-term "none" $1)))
                     (nt-modid ((t-conid) $1))
                     (nt-body ((t-lcbracket nt-topdecls t-rcbracket) $2))
                     (nt-topdecls (() null)
                                  ((nt-topdecl nt-topdecls-2) (cons $1 $2)))
                     (nt-topdecls-2 (() null)
                                    ((t-semicolon nt-topdecl nt-topdecls-2) (cons $2 $3)))
                     (nt-topdecl ((nt-decl) $1))
                     (nt-decl ((nt-gendecl) 'TODO)
                              ((nt-decl-2 nt-rhs) (make-declaration-term $1 (car $2) (cdr $2))))
                     (nt-decl-2 ((nt-funlhs) $1))
                     (nt-gendecl ((nt-vars t-coloncolon nt-type) 'TODO))
                     (nt-rhs ((t-equal nt-exp t-coloncolon nt-type) (cons $2 $4)))
                     (nt-vars ((nt-var nt-vars-2) (cons $1 $2)))
                     (nt-type ((nt-btype nt-type-2) (if (null? $2) $1 (make-function-type (cons $1 $2)))))
                     (nt-funlhs ((nt-var nt-funlhs-2) (cons $1 $2))
                                ((nt-apat nt-varop nt-apat) (list $2 $1 $3)))
                     (nt-exp ((t-backslash nt-exp-2 t-singlearrow nt-exp t-coloncolon nt-type) (make-function-term $2 $4 $6))
                             ((t-let nt-decls t-in nt-exp) (make-let-term $2 $4))
                             ((t-if nt-exp t-then nt-exp t-else nt-exp) (make-if-term $2 $4 $6))
                             ((t-case nt-exp t-of t-lcbracket nt-alts t-rcbracket) (make-case-term $2 $5))
                             ((nt-fexp) $1)
                             #;((t-lrbracket nt-exp t-coloncolon nt-type t-rrbracket) 'TODO)) ; creates a shift/reduce conflict
                     (nt-var ((t-varid) $1)
                             ((t-lrbracket t-varsym t-rrbracket) $2))
                     (nt-vars-2 (() null)
                                ((t-comma nt-var nt-vars-2) (cons $2 $3)))
                     (nt-btype ((nt-atype) $1))
                     (nt-type-2 (() null)
                                ((t-singlearrow nt-btype nt-type-2) (cons $2 $3)))
                     (nt-funlhs-2 (() null)
                                  ((nt-apat nt-funlhs-2) (cons $1 $2)))
                     (nt-apat ((nt-var) $1))
                     (nt-varop ((t-varsym) $1)
                               ((t-backtick t-varid t-backtick) $2))
                     (nt-exp-2 ((nt-apat) (list $1))
                               ((nt-apat nt-exp-2) (cons $1 $2)))
                     (nt-decls ((t-lcbracket nt-decls-2 t-rcbracket) $2))
                     (nt-alts ((nt-alt nt-alts-2) (cons $1 $2)))
                     (nt-fexp ((nt-aexp nt-fexp-2) (if (null? $2) $1 (make-application-term $1 $2))))
                     (nt-atype ((nt-gtycon) (make-type-constructor $1))
                               ((nt-tyvar) (make-type-variable $1))
                               ((t-lrbracket nt-type t-comma nt-type nt-atype-2 t-rrbracket) (make-tuple-type (cons $2 (cons $4 $5))))
                               ((t-lsbracket nt-type t-rsbracket) (make-list-type $2)))
                     (nt-gtycon ((nt-qtycon) $1))
                     (nt-qtycon ((nt-tycon) $1))
                     (nt-tycon ((t-conid) $1))
                     (nt-decls-2 (() null)
                                 ((nt-decl nt-decls-3) (cons $1 $2)))
                     (nt-alt ((nt-pat t-singlearrow nt-exp) (cons $1 $3)))
                     (nt-alts-2 (() null)
                                ((t-semicolon nt-alt nt-alts-2) (cons $2 $3)))
                     (nt-fexp-2 (() null)
                                ((nt-aexp nt-fexp-2) (cons $1 $2)))
                     (nt-aexp ((nt-qvar) $1)
                              ((nt-gcon) $1)
                              ((nt-literal) $1)
                              ((t-lrbracket nt-exp nt-aexp-2 t-rrbracket) (if (null? $3) $2 (make-tuple-term (cons $2 $3))))
                              ((t-lsbracket nt-exp nt-aexp-2 t-rsbracket) (make-list-term (cons $2 $3))))
                     (nt-tyvar ((t-varid) $1))
                     (nt-atype-2 (() null)
                                 ((t-comma nt-type nt-atype-2) (cons $2 $3)))
                     (nt-decls-3 (() null)
                                 ((t-semicolon nt-decl nt-decls-3) (cons $2 $3)))
                     (nt-pat ((nt-apat) $1))
                     (nt-qvar ((nt-qvarid) $1)
                              ((t-lrbracket nt-qvarsym t-rrbracket) $2))
                     (nt-gcon ((t-rbracketcon) 'TODO)
                              ((t-sbracketcon) (make-list-term null))
                              ((t-lrbracket t-comma nt-gcon-2 t-rrbracket) (make-tuplecon-term (+ $3 2)))
                              ((nt-qcon) $1))
                     (nt-literal ((t-integer) (make-integer-term $1))
                                 ((t-float) (make-float-term $1))
                                 ((t-char) (make-character-term $1))
                                 ((t-string) (make-list-term $1)))
                     (nt-aexp-2 (() null)
                                ((t-comma nt-exp nt-aexp-2) (cons $2 $3)))
                     (nt-qvarid ((t-varid) (make-identifier-term $1)))
                     (nt-qvarsym ((t-varsym) (make-identifier-term $1)))
                     (nt-gcon-2 (() 0)
                                ((t-comma nt-gcon-2) (+ $2 1)))
                     (nt-qcon ((nt-qconid) $1)
                              ((t-lrbracket nt-gconsym t-rrbracket) $2))
                     (nt-qconid ((t-conid) (make-identifier-term $1)))
                     (nt-gconsym ((t-colon) (make-identifier-term ":"))
                                 ((nt-qconsym) $1))
                     (nt-qconsym ((t-consym) (make-identifier-term $1))))))
  
  (define (read-haskell-syntax source-name input-port)
    (define module ((haskell-parser source-name) (lambda () (port-count-lines! input-port) (haskell-lexer input-port))))
    (map (lambda (x) (valid-type x)) (module-term-declarations module))
    (compile-haskell module))
)