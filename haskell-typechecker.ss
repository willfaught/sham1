(module haskell-typechecker mzscheme
  (require (only (lib "1.ss" "srfi") make-list unzip2 zip)
           (lib "haskell-compiler.ss" "hs")
           (lib "haskell-prelude.ss" "hs")
           (lib "haskell-terms.ss" "hs")
           (lib "haskell-types.ss" "hs")
           (only (lib "list.ss") foldl)
           (lib "match.ss")
           (lib "test.ss" "hs"))
  
  (provide valid-types)
  
  (define-struct constraint (left right) #f)
  
  (define type-variable-count 0)
  
  ; valid-types :: term -> boolean
  (define (valid-types module)
    (unify-constraints (reconstruct-module-types module))
    #t)
  
  ; fresh-type-variable :: type
  (define (fresh-type-variable)
    (set! type-variable-count (+ type-variable-count 1))
    (make-type-variable (string-append "t" (number->string type-variable-count))))
  
  ; lunzip2 :: [(a, b)] -> ([a], [b])
  (define (lunzip2 x)
    (let-values (((x y) (unzip2 x))) (list x y)))
  
  ; translate-type :: type -> type
  (define (translate-type type)
    (match type
      (($ type-constructor "Bool") (make-boolean-type))
      (($ type-constructor "Char") (make-character-type))
      (($ type-constructor "Int") (make-integer-type))
      (($ type-constructor "Integer") (make-integer-type))
      (($ type-constructor "Float") (make-float-type))
      (($ function-type t) (make-function-type (map translate-type t)))
      (x x)))
  
  ; reconstruct-types :: [(string, type)] -> term -> (type, [constraint])
  (define (reconstruct-types context term)
    (match term
      (($ application-term f a) (match-let* (((f-type f-constraints) (reconstruct-types context f))
                                             ((a-types a-constraints) (lunzip2 (map (lambda (x) (reconstruct-types context x)) a)))
                                             (type (fresh-type-variable))
                                             (constraints (cons (make-constraint f-type (make-function-type (append a-types (list type))))
                                                                (append f-constraints (foldl append null a-constraints)))))
                                  (list type constraints)))
      #;(($ case-term e a) (match-let* (((e-type e-constraints) (reconstruct-types context e)) ; need to add constraints between e and patterns
                                        ((a-types a-constraints) (lunzip2 (map (lambda (x) (reconstruct-types (cons (list (car x) e-type) context) (cdr x))) a))))
                             (list (car a-types) (append e-constraints (foldl append null a-constraints)))))
      (($ character-term c) (list (make-character-type) null))
      (($ declaration-term p e t) (if (equal? (length p) 1)
                                      (match-let (((type constraints) (reconstruct-types context e)))
                                        (list type (cons (make-constraint (list-ref (assoc (car p) context) 1) type) constraints)))
                                      (match-let (((type constraints) (reconstruct-types context (make-function-term (cdr p) e t))))
                                        (list type (cons (make-constraint (list-ref (assoc (car p) context) 1) type) constraints)))))
      (($ float-term f) (list (make-float-type) null))
      (($ function-term p b _) (match-let* ((p-types (map (lambda (x) (fresh-type-variable)) p)) 
                                            ((type constraints) (reconstruct-types (append (zip p p-types) context) b)))
                                 (list (make-function-type (append p-types (list type))) constraints)))
      (($ identifier-term i) (match (assoc i context)
                               ((_ type) (list type null))
                               (_ (error 'reconstruct-types "Not in scope: '~a'" i))))
      (($ if-term g t e) (match-let (((g-type g-constraints) (reconstruct-types context g))
                                     ((t-type t-constraints) (reconstruct-types context t))
                                     ((e-type e-constraints) (reconstruct-types context e)))
                           (list t-type (append g-constraints t-constraints e-constraints (list (make-constraint g-type (make-boolean-type))
                                                                                                (make-constraint t-type e-type))))))
      (($ integer-term i) (list (make-integer-type) null))
      (($ let-term d e) (match-let* ((context-2 (append (map (lambda (x) (list (car (declaration-term-patterns x)) (fresh-type-variable))) d) context))
                                     ((d-types d-constraints) (lunzip2 (map (lambda (x) (reconstruct-types context-2 x)) d)))
                                     ((e-type e-constraints) (reconstruct-types context-2 e)))
                          (list e-type (append (foldl append null d-constraints) e-constraints))))
      (($ list-term e) (if (null? e)
                           (list (make-list-type (fresh-type-variable)) null)
                           (match-let ((((head-type . tail-types) e-constraints) (lunzip2 (map (lambda (x) (reconstruct-types context x)) e))))
                             (list (make-list-type head-type)
                                   (append (map (lambda (x) (make-constraint head-type x)) tail-types)
                                           (foldl append null e-constraints))))))
      (($ tuple-term e) (match-let (((e-types e-constraints) (lunzip2 (map (lambda (x) (reconstruct-types context x)) e))))
                          (list (make-tuple-type e-types) (foldl append null e-constraints))))
      (($ tuplecon-term a) (let ((types (map (lambda (x) (fresh-type-variable)) (make-list a))))
                             (list (make-function-type (append types (list (make-tuple-type types)))) null)))))
  
  ; generalize :: type -> type
  (define (generalize type)
  
  ; reconstruct-module-types :: term -> [constraint]
  (define (reconstruct-module-types module)
    (match-let* ((decls (module-term-declarations module))
                 (context (map (lambda (x) (list (car (declaration-term-patterns x)) (fresh-type-variable))) decls))
                 ((types constraints) (lunzip2 (map (lambda (x) (reconstruct-types context x)) decls))))
      (foldl append null constraints)))
  
  ; contains-type? :: type -> type -> boolean
  (define (contains-type? container-type containee-type)
    (if (equal? container-type containee-type)
        #t
        (match container-type
          (($ function-type t) (foldl (lambda (x y) (or x y)) #f (map (lambda (x) (contains-type? x containee-type)) t)))
          (($ list-type t) (contains-type? t containee-type))
          (($ tuple-type t) (foldl (lambda (x y) (or x y)) #f (map (lambda (x) (contains-type? x containee-type)) t)))
          (_ #f))))
  
  ; substitute-in-constraints :: type -> type -> [constraint] -> [constraint]
  (define (substitute-in-constraints from-type to-type constraints)
    (map (match-lambda (($ constraint left-type right-type) (make-constraint (substitute-type from-type to-type left-type)
                                                                             (substitute-type from-type to-type right-type))))
         constraints))
  
  ; substitute-type :: type -> type -> type -> type
  (define (substitute-type from-type to-type type)
    (if (equal? from-type type)
        to-type
        (match type
          (($ function-type t) (make-function-type (map (lambda (x) (substitute-type from-type to-type x)) t)))
          (($ list-type t) (make-list-type (substitute-type from-type to-type t)))
          (($ tuple-type t) (make-tuple-type (map (lambda (x) (substitute-type from-type to-type x)) t)))
          (t t))))
  
  ; substitute-types :: [(type, type)] -> type -> type
  (define (substitute-types mappings type)
    (match mappings
      (((from-type to-type) . tail) (substitute-types tail (substitute-type from-type to-type type)))
      (() type)))
  
  ; unify-constraints :: [constraint] -> [(type, type)]
  (define (unify-constraints constraints)
    ; zip-function-types :: ([type], [type]) -> [constraint]
    (define (zip-function-types types)
      (match types
        (((a . ()) (b c . d)) (list (make-constraint a (make-function-type (append (list b c) d)))))
        (((a b . c) (d . ())) (list (make-constraint (make-function-type (append (list a b) c)) d)))
        (((a . b) (c . d)) (cons (make-constraint a c) (zip-function-types (list b d))))
        ((() ()) null)))
    (match constraints
      ((($ constraint left-type right-type) . rest)
       (cond ((equal? left-type right-type)
              (unify-constraints rest))
             ((and (type-variable? left-type)
                   (not (contains-type? right-type left-type)))
              (cons (list left-type right-type)
                    (unify-constraints (substitute-in-constraints left-type right-type rest))))
             ((and (type-variable? right-type)
                   (not (contains-type? left-type right-type)))
              (cons (list right-type left-type)
                    (unify-constraints (substitute-in-constraints right-type left-type rest))))
             ((and (function-type? left-type)
                   (function-type? right-type))
              (unify-constraints (append (zip-function-types (list (function-type-types left-type) (function-type-types right-type))) rest)))
             (else (error 'unify-constraints "cannot unify the constraint: ~a = ~a" left-type right-type))))
      (() null)))
  
  (define tests
    (list (make-test "character-term 1"
                     (make-character-term "a")
                     (make-character-type))
          (make-test "integer-term 1"
                     (make-integer-term "1")
                     (make-integer-type))
          (make-test "float-term 1"
                     (make-float-term "2.3")
                     (make-float-type))
          (make-test "list-term 1"
                     (make-list-term null)
                     (make-list-type (make-type-variable "t1")))
          (make-test "list-term 2"
                     (make-list-term (list (make-character-term "a")))
                     (make-list-type (make-character-type)))
          (make-test "list-term 3"
                     (make-list-term (list (make-float-term "1.2")
                                           (make-float-term "3.4")))
                     (make-list-type (make-float-type)))
          (make-test "tuple-term 1"
                     (make-tuple-term (list (make-character-term "a")
                                            (make-float-term "1.2")))
                     (make-tuple-type (list (make-character-type)
                                            (make-float-type))))
          (make-test "tuple-term 2"
                     (make-tuple-term (list (make-character-term "a")
                                            (make-float-term "1.2")
                                            (make-integer-term "3")))
                     (make-tuple-type (list (make-character-type)
                                            (make-float-type)
                                            (make-integer-type))))
          (make-test "tuplecon-term 1"
                     (make-tuplecon-term 2)
                     (make-function-type (list (make-type-variable "t1")
                                               (make-type-variable "t2")
                                               (make-tuple-type (list (make-type-variable "t1")
                                                                      (make-type-variable "t2"))))))
          (make-test "tuplecon-term 2"
                     (make-tuplecon-term 3)
                     (make-function-type (list (make-type-variable "t1")
                                               (make-type-variable "t2")
                                               (make-type-variable "t3")
                                               (make-tuple-type (list (make-type-variable "t1")
                                                                      (make-type-variable "t2")
                                                                      (make-type-variable "t3"))))))
          (make-test "let-term 1"
                     (make-let-term (list (make-declaration-term (list "a")
                                                                 (make-character-term "a")
                                                                 #f))
                                    (make-float-term "1.2"))
                     (make-float-type))
          (make-test "let-term 2"
                     (make-let-term (list (make-declaration-term (list "a")
                                                                 (make-character-term "a")
                                                                 #f))
                                    (make-identifier-term "a"))
                     (make-character-type))
          (make-test "let-term 3"
                     (make-let-term (list (make-declaration-term (list "a")
                                                                 (make-identifier-term "a")
                                                                 #f))
                                    (make-identifier-term "a"))
                     (make-type-variable "t1"))
          (make-test "let-term 4"
                     (make-let-term (list (make-declaration-term (list "a")
                                                                 (make-character-term "a")
                                                                 #f)
                                          (make-declaration-term (list "b")
                                                                 (make-identifier-term "a")
                                                                 #f))
                                    (make-identifier-term "b"))
                     (make-character-type))
          (make-test "let-term 5"
                     (make-let-term (list (make-declaration-term (list "a")
                                                                 (make-identifier-term "b")
                                                                 #f)
                                          (make-declaration-term (list "b")
                                                                 (make-character-term "a")
                                                                 #f))
                                    (make-identifier-term "a"))
                     (make-character-type))
          (make-test "let-term 6"
                     (make-let-term (list (make-declaration-term (list "a" "x")
                                                                 (make-character-term "a")
                                                                 #f))
                                    (make-identifier-term "a"))
                     (make-function-type (list (make-type-variable "t2") (make-character-type))))
          (make-test "let-term 7"
                     (make-let-term (list (make-declaration-term (list "a" "x" "y")
                                                                 (make-identifier-term "y")
                                                                 #f))
                                    (make-identifier-term "a"))
                     (make-function-type (list (make-type-variable "t2") (make-type-variable "t3") (make-type-variable "t3"))))
          (make-test "let-term 8"
                     (make-let-term (list (make-declaration-term (list "a" "x")
                                                                 (make-identifier-term "x")
                                                                 #f)
                                          (make-declaration-term (list "b")
                                                                 (make-application-term (make-identifier-term "a")
                                                                                        (list (make-character-term "a")))
                                                                 #f)
                                          (make-declaration-term (list "c")
                                                                 (make-application-term (make-identifier-term "a")
                                                                                        (list (make-float-term "1.2")))
                                                                 #f))
                                    (make-identifier-term "a"))
                     (make-function-type (list (make-type-variable "t2")
                                               (make-type-variable "t2"))))
          (make-test "function-term 1"
                     (make-function-term (list "x")
                                         (make-character-term "a")
                                         #f)
                     (make-function-type (list (make-type-variable "t1")
                                               (make-character-type))))
          (make-test "function-term 2"
                     (make-function-term (list "x")
                                         (make-identifier-term "x")
                                         #f)
                     (make-function-type (list (make-type-variable "t1")
                                               (make-type-variable "t1"))))
          (make-test "function-term 3"
                     (make-function-term (list "x" "y")
                                         (make-identifier-term "y")
                                         #f)
                     (make-function-type (list (make-type-variable "t1")
                                               (make-type-variable "t2")
                                               (make-type-variable "t2"))))
          (make-test "application-term 1"
                     (make-application-term (make-function-term (list "x")
                                                                (make-character-term "a")
                                                                #f)
                                            (list (make-float-term "1.2")))
                     (make-character-type))
          (make-test "application-term 2"
                     (make-application-term (make-function-term (list "x")
                                                                (make-identifier-term "x")
                                                                #f)
                                            (list (make-character-term "a")))
                     (make-character-type))
          (make-test "application-term 3"
                     (make-application-term (make-function-term (list "x" "y")
                                                                (make-identifier-term "y")
                                                                #f)
                                            (list (make-character-term "a")
                                                  (make-float-term "1.2")))
                     (make-float-type))))
  
  (define (debug term)
    (match-let* (((type constraints) (reconstruct-types null term))
                 (mappings (unify-constraints constraints))
                 (newtype (substitute-types mappings type)))
      (display "term:")
      (newline)
      (display term)
      (newline)
      (display "type:")
      (newline)
      (display type)
      (newline)
      (display "constraints:")
      (newline)
      (display constraints)
      (newline)
      (display "mappings:")
      (newline)
      (display mappings)
      (newline)
      (display "new type:")
      (newline)
      (display newtype)
      ))
  
  (define (run-all-tests)
    (run-tests (lambda (x)
                 (set! type-variable-count 0)
                 (match-let* (((type constraints) (reconstruct-types null x)))
                   (substitute-types (unify-constraints constraints) type)))
               tests)))