(module haskell-typechecker mzscheme
  (require (lib "haskell-compiler.ss" "hs")
           (lib "list.ss" "srfi" "1")
           (lib "match.ss")
           (lib "test.ss" "hs"))
  
  (define-struct type () #f)
  (define-struct (boolean-type type) () #f)
  (define-struct (character-type type) () #f)
  (define-struct (float-type type) () #f)
  (define-struct (function-type type) (types) #f)
  (define-struct (integer-type type) () #f)
  (define-struct (list-type type) (type) #f)
  (define-struct (tuple-type type) (types) #f)
  (define-struct (type-abstraction type) (parameters) #f)
  (define-struct (type-application type) (term types) #f)
  (define-struct (type-variable type) (identifier) #f)
  (define-struct (universal-type type) (type-variable type) #f)
  
  (define (term-type context term)
    (match term
      (($ application-term f a) (let ((f-type (term-type context f))
                                      (a-types (map (lambda (x) (term-type context x)) a)))
                                  (if (function-type? f-type)
                                      (let ((f-types (function-type-types f-type)))
                                        (if (not (equal? (reverse (cdr (reverse f-types))) a-types))
                                            (error 'term-type "param and arg types don't match")
                                            (car (reverse f-types))))
                                      (error 'term-type "applied term not a function"))))
      (($ case-term _ a) (term-type context (cdr (car a))))
      (($ character-term _) (make-character-type))
      (($ declaration-term p e t) (if (equal? (length p) 1)
                                      (term-type context e)
                                      (if (equal? (- (length p) 1) (length t))
                                          (term-type context (make-function-term (cdr p) e t))
                                          (error 'term-type "missing or extra param types"))))
      (($ float-term _) (make-float-type))
      (($ function-term p b t) (if (equal? (length p) (length t))
                                   (make-function-type (append t (list (term-type (append (zip p t) context) b))))
                                   (error 'term-type "missing or extra param types")))
      (($ identifier-term i) (let ((item (assoc i context)))
                               (if (pair? item)
                                   (list-ref item 1)
                                   (error 'term-type "free variable"))))
      (($ if-term g t e) (let ((g-type (term-type context g))
                               (t-type (term-type context t))
                               (e-type (term-type context e)))
                           (if (and (equal? g-type (make-boolean-type)) (equal? t-type e-type)) t-type (error 'term-type "bad if types"))))
      (($ integer-term _) (make-integer-type))
      (($ let-term d e) (term-type (append (map (lambda (x) (list (car (declaration-term-patterns x)) (term-type context x))) d) context) e))))
  
  
  (define tests
    (list (make-test "application-term 1"
                     (make-application-term (make-function-term (list "x")
                                                                (make-identifier-term "x")
                                                                (list (make-integer-type)))
                                            (list (make-integer-term "2")))
                     (make-integer-type))
          (make-test "application-term 2"
                     (make-application-term (make-function-term (list "x" "y")
                                                                (make-identifier-term "y")
                                                                (list (make-integer-type)
                                                                      (make-character-type)))
                                            (list (make-integer-term "2")
                                                  (make-character-term "c")))
                     (make-character-type))
          (make-test "application-term 3"
                     (make-application-term (make-function-term (list "x")
                                                                (make-character-term "c")
                                                                (list (make-integer-type)))
                                            (list (make-integer-term "2")))
                     (make-character-type))
          (make-test "case-term 1"
                     (make-case-term (make-integer-term "2")
                                     (list (cons "x" (make-character-term "c"))))
                     (make-character-type))
          (make-test "character-term 1"
                     (make-character-term "c")
                     (make-character-type))
          (make-test "declaration-term 1"
                     (make-declaration-term (list "x")
                                            (make-integer-term "2")
                                            (make-integer-type))
                     (make-integer-type))
          (make-test "declaration-term 2"
                     (make-declaration-term (list "x" "y")
                                            (make-integer-term "2")
                                            (make-character-type))
                     (make-function-type (list (make-character-type) (make-integer-type))))
          (make-test "float-term 1"
                     (make-float-term "c")
                     (make-float-type))
          (make-test "function-term 1"
                     (make-function-term (list "x")
                                         (make-identifier-term "x")
                                         (list (make-integer-type)))
                     (make-function-type (list (make-integer-type) (make-integer-type))))
          (make-test "function-term 2"
                     (make-function-term (list "x")
                                         (make-integer-term "2")
                                         (list (make-character-type)))
                     (make-function-type (list (make-character-type) (make-integer-type))))
          (make-test "function-term 3"
                     (make-function-term (list "x" "y")
                                         (make-integer-term "2")
                                         (list (make-character-type)
                                               (make-boolean-type)))
                     (make-function-type (list (make-character-type) (make-boolean-type) (make-integer-type))))))
  
  (define (run-all-tests)
    (run-tests (lambda (x) (term-type null x)) tests)))