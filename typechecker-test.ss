(module typechecker-test mzscheme
  (require (lib "match.ss")
           (lib "parsers.ss" "haskell")
           (lib "typechecker.ss" "haskell")
           (lib "types.ss" "haskell")
           (planet "test.ss" ("schematics" "schemeunit.plt" 2)))
  
  (provide run-tests)
  
  ; parse-expression :: string -> term
  (define (parse-expression expression)
    (let ((port (open-input-string expression)))
      (port-count-lines! port)
      (test-expression-parser (lambda () (language-lexer port)))))
  
  ; parse-type :: string -> type
  (define (parse-type type)
    (let ((port (open-input-string type)))
      (port-count-lines! port)
      (normalize-type-variables (map-type (lambda (x) (if (type-constructor? x) (translate-type-constructor x) x))
                                          (test-type-parser (lambda () (language-lexer port)))))))
  
  ; run-tests :: (string)
  (define (run-tests)
    (define (results x y)
      (cond ((test-failure? x) (cons (test-result-test-case-name x) y))
            ((test-error? x) (cons (test-result-test-case-name x) y))
            (else y)))
      (fold-test-results results null typechecker-test-suite))
  
  ; test-expression-parser :: parser
  (define test-expression-parser (expression-parser "test"))
  
  ; test-case-e :: string string string -> test-case
  (define (test-case-e name expression type)
    (test-equal? name (reconstruct-type null (parse-expression expression)) (parse-type type)))
  
  ; test-case-x :: string string -> test-case
  (define (test-case-x name expression)
    (test-exn name (lambda (x) #t) (lambda () (reconstruct-type null (parse-expression expression)))))
  
  ; test-type-parser :: parser
  (define test-type-parser (type-parser "test"))
  
  ; typechecker-test-suite :: schemeunit-test-suite
  (define typechecker-test-suite
    (test-suite "typechecker"
                (test-case-e "ap1" "(\\x -> 1) 1" "Int")
                (test-case-e "ap2" "(\\x -> x) 1" "Int")
                (test-case-e "ap3" "(\\x -> \\y -> x) 1" "t -> Int")
                (test-case-e "ap4" "(\\x y -> x) 1" "t -> Int")
                (test-case-e "ap5" "(\\x -> [x]) 1" "[Int]")
                (test-case-e "ap6" "(\\x -> (x, x)) 1" "(Int, Int)")
                (test-case-e "ap7" "(\\x y -> 1) 2 3" "Int")
                (test-case-x "ap8" "1 2")
                (test-case-x "ap9" "(\\x -> x) 1 2")
                (test-case-x "ap10" "let { i x = x ; j = i 1 } in i 'a'")
                (test-case-e "ch1" "'a'" "Char")
                (test-case-e "in1" "1" "Int")
                (test-case-e "fl1" "1.2" "Float")
                (test-case-e "fu1" "\\x -> 1" "t -> Int")
                (test-case-e "fu2" "\\x -> x" "t -> t")
                (test-case-e "fu3" "\\x -> \\y -> x" "t -> t1 -> t")
                (test-case-e "fu4" "\\x y -> x" "t -> t1 -> t")
                (test-case-e "fu5" "\\x -> \\y -> y" "t -> t1 -> t1")
                (test-case-e "fu6" "\\x y -> y" "t -> t1 -> t1")
                (test-case-e "fu7" "\\x -> [x]" "t -> [t]")
                (test-case-e "fu8" "\\x -> (x, x)" "t -> (t, t)")
                (test-case-x "id1" "x")
                (test-case-e "id2" "(:)" "t -> [t] -> [t]")
                (test-case-e "id3" "head" "[t] -> t")
                (test-case-e "id4" "tail" "[t] -> [t]")
                (test-case-e "id5" "fst" "(t, t1) -> t")
                (test-case-e "id6" "snd" "(t, t1) -> t1")
                #;(test-case-e "null" "[t] -> Bool")
                #;(test-case-e "if1" "if True then 1 else 2" "Int")
                #;(test-case-e "if2" "if False then 1 else 2" "Int")
                #;(test-case-x "if3" "if 1 then 2 else 3")
                #;(test-case-x "if4" "if True then 1 else 'a'")
                (test-case-e "le1" "let { i = 1 } in 2.3" "Float")
                (test-case-e "le2" "let { i = 1 } in i" "Int")
                (test-case-e "le3" "let { i = i } in i" "t")
                (test-case-e "le4" "let { i = 2 ; j = i } in j" "Int")
                (test-case-e "le5" "let { i = j ; j = 2 } in j" "Int")
                (test-case-e "le6" "let { i x = 2 } in i" "t -> Int")
                (test-case-e "le7" "let { i x = x } in i" "t -> t")
                (test-case-e "le8" "let { i x y = y } in i" "t -> t1 -> t1")
                (test-case-e "le9" "let { i x = x ; j = i 2; k = i 3 } in i" "Int -> Int")
                (test-case-e "le10" "let { i x = 2 } in i 3" "Int")
                (test-case-e "le11" "let { i x = x } in i 2" "Int")
                (test-case-e "le12" "let { i x = x } in let { j = i 2 ; k = i 3.4 } in i" "t -> t")
                (test-case-e "le13" "let { i x = x } in let { j = i 2 ; k = i 3.4 } in j" "Int")
                (test-case-x "le16" "let { i = (i, i) } in i")
                (test-case-x "le17" "let { i x = x ; j = i 1 ; k = i 2.3 } in i")
                (test-case-e "li1" "[]" "[t]")
                (test-case-e "li2" "[1]" "[Int]")
                (test-case-e "li3" "\"\"" "[t]")
                (test-case-e "li4" "\"foo\"" "[Char]")
                (test-case-x "li5" "[1, 'a']")
                (test-case-e "sc1" ":scheme Int -> Int -> Int \"primitive:int-add\"" "Int -> Int -> Int")
                (test-case-e "tu1" "('a', 1)" "(Char, Int)")
                (test-case-e "tu2" "('b', 1, 1)" "(Char, Int, Int)")
                (test-case-e "tc1" "(,)" "t -> t1 -> (t, t1)")
                (test-case-e "tc2" "(,,)" "t -> t1 -> t2 -> (t, t1, t2)")
                (test-case-e "tc3" "(,) 1" "t -> (Int, t)")
                (test-case-e "tc4" "(,) 1 2" "(Int, Int)")
                (test-case-e "tc5" "(,,) 1" "t -> t1 -> (Int, t, t1)")
                (test-case-e "tc6" "(,,) 1 2" "t -> (Int, Int, t)")
                (test-case-e "tc7" "(,,) 1 2 3" "(Int, Int, Int)")
                (test-case-x "tc8" "(,) 1 2 3")
                (test-case-x "tc9" "(,,) 1 2 3 4"))))