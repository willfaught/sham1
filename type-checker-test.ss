(module type-checker-test mzscheme
  (require (lib "match.ss")
           (lib "parsers.ss" "haskell")
           (lib "type-checker.ss" "haskell")
           (lib "types.ss" "haskell")
           (planet "test.ss" ("schematics" "schemeunit.plt" 2)))
  
  (provide run-tests)
  
  ; parse-declaration :: string -> term
  (define (parse-declaration expression)
    (let ((port (open-input-string expression)))
      (port-count-lines! port)
      (test-declaration-parser (lambda () (language-lexer port)))))
  
  ; parse-expression :: string -> term
  (define (parse-expression expression)
    (let ((port (open-input-string expression)))
      (port-count-lines! port)
      (test-expression-parser (lambda () (language-lexer port)))))
  
  ; parse-module :: string -> term
  (define (parse-module expression)
    (let ((port (open-input-string expression)))
      (port-count-lines! port)
      (test-module-parser (lambda () (language-lexer port)))))
  
  ; parse-type :: string -> type
  (define (parse-type type)
    (let ((port (open-input-string type)))
      (port-count-lines! port)
      (normalize-type-variables (map-type (lambda (x) (if (type-constructor? x) (translate-type-constructor x) x))
                                          (test-type-parser (lambda () (language-lexer port)))))))
  
  ; run-tests :: (string)
  (define (run-tests)
    (define (results x y)
      (cond ((test-failure? x) (cons (test-result-test-case-name x) y))
            ((test-error? x) (cons (test-result-test-case-name x) y))
            (else y)))
      (fold-test-results results null typechecker-test-suite))
  
  ; test-declaration-parser :: parser
  (define test-declaration-parser (declaration-parser "test"))
  
  ; test-expression-parser :: parser
  (define test-expression-parser (expression-parser "test"))
  
  ; test-case-e :: string string string -> test-case
  (define (test-case-e name expression type)
    (test-equal? name (reconstruct-type null (parse-expression expression)) (parse-type type)))
  
  ; test-case-x :: string string -> test-case
  (define (test-case-x name expression)
    (test-exn name (lambda (x) #t) (lambda () (reconstruct-type null (parse-expression expression)))))
  
  ; test-case-mnx :: string string -> test-case
  (define (test-case-mnx name module)
    (test-not-exn name (lambda () (module-context null (parse-module module)))))
  
  ; test-case-mx :: string string -> test-case
  (define (test-case-mx name module)
    (test-exn name (lambda (x) #t) (lambda () (module-context null (parse-module module)))))
  
  ; test-module-parser :: parser
  (define test-module-parser (module-parser "test"))
  
  ; test-type-parser :: parser
  (define test-type-parser (type-parser "test"))
  
  ; typechecker-test-suite :: schemeunit-test-suite
  (define typechecker-test-suite
    (test-suite "typechecker"
                (test-case-e "ap1" "(\\x -> 1) 1" "Int")
                (test-case-e "ap2" "(\\x -> x) 1" "Int")
                (test-case-e "ap3" "(\\x -> \\y -> x) 1" "t -> Int")
                (test-case-e "ap4" "(\\x y -> x) 1" "t -> Int")
                (test-case-e "ap5" "(\\x -> [x]) 1" "[Int]")
                (test-case-e "ap6" "(\\x -> (x, x)) 1" "(Int, Int)")
                (test-case-e "ap7" "(\\x y -> 1) 2 3" "Int")
                (test-case-x "ap8" "1 2")
                (test-case-x "ap9" "(\\x -> x) 1 2")
                (test-case-x "ap10" "let { i x = x ; j = i 1 } in i 'a'")
                (test-case-e "ch1" "'a'" "Char")
                (test-case-mnx "da1" "{}")
                (test-case-mnx "da2" "{ data A = A { a :: A } | B { b :: A } | C ; c = B (A (B C)) }")
                (test-case-mx "da3" "{ data A = A { a :: A } | B { b :: A } | C ; c = A 1 }")
                (test-case-mx "da4" "{ data A = A { a :: A } | B { b :: A } | C ; c = B 1 }")
                (test-case-mx "da5" "{ data A = A { a :: A } | B { b :: A } | C ; c = C 1 }")
                (test-case-mx "da6" "{ data A = A { a :: A } | B { b :: A } | C ; c = A B }")
                (test-case-mx "da7" "{ data A = A { a :: A } | B { b :: A } | C ; c = B A }")
                (test-case-mnx "da8" "{ data A = A { a :: A } | B { b :: A } | C ; c = a (b (a (A (B (A C))))) ; d = a C ; e = b C }")
                (test-case-mx "da9" "{ data A = A { a :: A } | B { b :: A } | C ; c = a 1 }")
                (test-case-mx "da10" "{ data A = A { a :: A } | B { b :: A } | C ; c = b 1 }")
                (test-case-mnx "da11" "{ data A = A { a :: A } | B { b :: A } | C ; c = isA (A C) ; d = isA (B C) ; e = isA C }")
                (test-case-mnx "da12" "{ data A = A { a :: A } | B { b :: A } | C ; c = isB (A C) ; d = isB (B C) ; e = isB C }")
                (test-case-mnx "da13" "{ data A = A { a :: A } | B { b :: A } | C ; c = isC (A C) ; d = isC (B C) ; e = isC C }")
                (test-case-mx "da14" "{ data A = A { a :: A } | B { b :: A } | C ; c = isA 1 }")
                (test-case-mx "da15" "{ data A = A { a :: A } | B { b :: A } | C ; c = isB 1 }")
                (test-case-mx "da16" "{ data A = A { a :: A } | B { b :: A } | C ; c = isC 1 }")
                (test-case-mnx "da17" "{ data A = A { a :: B } | B ; data B = C { b :: A } | D ; c = A (C B) ; d = A D ; e = C (A D) ; f = C B }")
                (test-case-e "if1" "if True then 1 else 2" "Int")
                (test-case-x "if2" "if 1 then 2 else 3")
                (test-case-x "if3" "if True then 1 else 'a'")
                (test-case-e "in1" "1" "Int")
                (test-case-e "fl1" "1.2" "Float")
                (test-case-e "fu1" "\\x -> 1" "t -> Int")
                (test-case-e "fu2" "\\x -> x" "t -> t")
                (test-case-e "fu3" "\\x -> \\y -> x" "t -> t1 -> t")
                (test-case-e "fu4" "\\x y -> x" "t -> t1 -> t")
                (test-case-e "fu5" "\\x -> \\y -> y" "t -> t1 -> t1")
                (test-case-e "fu6" "\\x y -> y" "t -> t1 -> t1")
                (test-case-e "fu7" "\\x -> [x]" "t -> [t]")
                (test-case-e "fu8" "\\x -> (x, x)" "t -> (t, t)")
                (test-case-x "id1" "x")
                (test-case-e "id2" "(:)" "t -> [t] -> [t]")
                (test-case-e "id3" "head" "[t] -> t")
                (test-case-e "id4" "tail" "[t] -> [t]")
                (test-case-e "id5" "fst" "(t, t1) -> t")
                (test-case-e "id6" "snd" "(t, t1) -> t1")
                (test-case-e "id7" "False" "Bool")
                (test-case-e "id8" "True" "Bool")
                #;(test-case-e "null" "[t] -> Bool")
                (test-case-e "le1" "let { i = 1 } in 2.3" "Float")
                (test-case-e "le2" "let { i = 1 } in i" "Int")
                (test-case-e "le3" "let { i = i } in i" "t")
                (test-case-e "le4" "let { i = 2 ; j = i } in j" "Int")
                (test-case-e "le5" "let { i = j ; j = 2 } in j" "Int")
                (test-case-e "le6" "let { i x = 2 } in i" "t -> Int")
                (test-case-e "le7" "let { i x = x } in i" "t -> t")
                (test-case-e "le8" "let { i x y = y } in i" "t -> t1 -> t1")
                (test-case-e "le9" "let { i x = x ; j = i 2; k = i 3 } in i" "Int -> Int")
                (test-case-e "le10" "let { i x = 2 } in i 3" "Int")
                (test-case-e "le11" "let { i x = x } in i 2" "Int")
                (test-case-e "le12" "let { i x = x } in let { j = i 2 ; k = i 3.4 } in i" "t -> t")
                (test-case-e "le13" "let { i x = x } in let { j = i 2 ; k = i 3.4 } in j" "Int")
                (test-case-x "le16" "let { i = [i] } in i")
                (test-case-x "le17" "let { i = (i, i) } in i")
                (test-case-x "le18" "let { i x = x ; j = i 1 ; k = i 2.3 } in i")
                (test-case-e "li1" "[]" "[t]")
                (test-case-e "li2" "[1]" "[Int]")
                (test-case-e "li3" "\"\"" "[t]")
                (test-case-e "li4" "\"foo\"" "[Char]")
                (test-case-x "li5" "[1, 'a']")
                (test-case-mnx "mo1" "{}")
                (test-case-mnx "mo2" "{ i = 1 }")
                (test-case-mnx "mo3" "{ i = i }")
                (test-case-mnx "mo4" "{ i x = 1 }")
                (test-case-mnx "mo5" "{ i x = x }")
                (test-case-mnx "mo6" "{ i x y = x }")
                (test-case-mnx "mo7" "{ i = 1 ; j = i }")
                (test-case-mnx "mo8" "{ i = j ; j = 1 }")
                (test-case-mnx "mo9" "{ i = j ; j = i }")
                (test-case-mnx "mo10" "{ i = 1 ; j = i }")
                (test-case-mnx "mo11" "{ i x = x ; j = i 1 }")
                (test-case-mx "mo12" "{ i = 1 ; j = i 2 }")
                (test-case-mx "mo13" "{ i x = x ; j = i 1 2 }")
                (test-case-mnx "mo14" "{ i x = x ; j = i 1 ; k = 2 }")
                (test-case-mx "mo15" "{ i x = x ; j = i 1 ; k = i 'a' }")
                (test-case-mnx "mo16" "{ i = let { i x = x } in i ; j = i 1 }")
                (test-case-mx "mo17" "{ i = [i] }")
                (test-case-mx "mo18" "{ i = (i, i) }")
                (test-case-e "sc1" ":scheme Int -> Int -> Int \"primitive:int-add\"" "Int -> Int -> Int")
                (test-case-e "tu1" "('a', 1)" "(Char, Int)")
                (test-case-e "tu2" "('b', 1, 1)" "(Char, Int, Int)")
                (test-case-e "tc1" "(,)" "t -> t1 -> (t, t1)")
                (test-case-e "tc2" "(,,)" "t -> t1 -> t2 -> (t, t1, t2)")
                (test-case-e "tc3" "(,) 1" "t -> (Int, t)")
                (test-case-e "tc4" "(,) 1 2" "(Int, Int)")
                (test-case-e "tc5" "(,,) 1" "t -> t1 -> (Int, t, t1)")
                (test-case-e "tc6" "(,,) 1 2" "t -> (Int, Int, t)")
                (test-case-e "tc7" "(,,) 1 2 3" "(Int, Int, Int)")
                (test-case-x "tc8" "(,) 1 2 3")
                (test-case-x "tc9" "(,,) 1 2 3 4"))))